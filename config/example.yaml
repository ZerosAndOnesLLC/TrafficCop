# TrafficCop Configuration Example
# Traefik v3 compatible configuration format

# Entry points define the addresses the proxy listens on
entryPoints:
  web:
    address: ":80"
    http:
      redirections:
        entryPoint:
          to: websecure
          scheme: https
          permanent: true

  websecure:
    address: ":443"
    http:
      tls:
        certResolver: letsencrypt

# Dynamic HTTP routing configuration
http:
  # Routers define how requests are matched to services
  routers:
    api-router:
      entryPoints:
        - websecure
      rule: "Host(`api.example.com`) && PathPrefix(`/v1`)"
      service: api
      middlewares:
        - rate-limit
        - auth-headers
      priority: 100
      tls:
        certResolver: letsencrypt
        domains:
          - main: api.example.com

    api-public:
      entryPoints:
        - web
        - websecure
      rule: "Host(`api.example.com`) && PathPrefix(`/public`)"
      service: api
      priority: 90

    webapp-router:
      entryPoints:
        - web
        - websecure
      rule: "Host(`app.example.com`)"
      service: webapp
      middlewares:
        - compress
      priority: 50

    static-router:
      entryPoints:
        - web
      rule: "Host(`static.example.com`) || PathPrefix(`/static`)"
      service: static
      priority: 10

  # Services define backend server pools
  services:
    api:
      loadBalancer:
        servers:
          - url: "http://10.0.0.1:8080"
          - url: "http://10.0.0.2:8080"
          - url: "http://10.0.0.3:8080"
        sticky:
          cookie:
            name: SERVERID
            secure: true
            httpOnly: true
        healthCheck:
          path: "/health"
          interval: "10s"
          timeout: "5s"
        passHostHeader: true

    webapp:
      loadBalancer:
        servers:
          - url: "http://10.0.1.1:3000"
          - url: "http://10.0.1.2:3000"
        healthCheck:
          path: "/"
          interval: "15s"

    static:
      loadBalancer:
        servers:
          - url: "http://10.0.2.1:80"

  # Middlewares define request/response transformations
  middlewares:
    rate-limit:
      rateLimit:
        average: 100
        burst: 50
        period: "1s"

    auth-headers:
      headers:
        customRequestHeaders:
          X-Request-ID: "${uuid}"
        customResponseHeaders:
          X-Frame-Options: "DENY"
          X-Content-Type-Options: "nosniff"
          # Empty value removes the header
          Server: ""

    compress:
      compress:
        minResponseBodyBytes: 1024

    retry-middleware:
      retry:
        attempts: 3
        initialInterval: "100ms"

    strip-api:
      stripPrefix:
        prefixes:
          - "/api"

    add-prefix:
      addPrefix:
        prefix: "/v1"

    redirect-https:
      redirectScheme:
        scheme: https
        permanent: true

  # ServersTransport for backend connection settings
  serversTransports:
    secure-transport:
      insecureSkipVerify: false
      maxIdleConnsPerHost: 200
      forwardingTimeouts:
        dialTimeout: "30s"
        idleConnTimeout: "90s"

# TLS configuration
tls:
  certificates:
    - certFile: "/etc/certs/server.crt"
      keyFile: "/etc/certs/server.key"

  options:
    default:
      minVersion: "VersionTLS12"
      cipherSuites:
        - "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"
        - "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"
      sniStrict: true

# Certificate resolvers (ACME / Let's Encrypt)
certificatesResolvers:
  letsencrypt:
    acme:
      email: "admin@example.com"
      storage: "/etc/acme/acme.json"
      # Use staging for testing: https://acme-staging-v02.api.letsencrypt.org/directory
      # caServer: "https://acme-v02.api.letsencrypt.org/directory"
      httpChallenge:
        entryPoint: web

# Metrics configuration
metrics:
  prometheus:
    address: ":9090"
    addEntryPointsLabels: true
    addServicesLabels: true

# Logging
log:
  level: "INFO"

accessLog:
  filePath: "/var/log/trafficcop/access.log"
  format: "json"
